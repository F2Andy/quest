<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Developers</title>
    <link rel="stylesheet" href="/bootstrap.min.css">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="container">
      <h1>Developers</h1>
      <h2>Join In</h2>

<p>Quest is an open-source software project, hosted at <a href="https://github.com/textadventures/quest">https://github.com/textadventures/quest</a></p>

<p>To compile the source code, you will need Visual Studio 2010 or Visual Studio 2012. You can edit the desktop version of Quest for free using <a href="http://www.microsoft.com/visualstudio/eng/downloads#d-express-windows-desktop">Visual Studio Express 2012 for Windows Desktop</a>.</p>

<p>The code is a mixture of C# (for the internals) and VB.NET (for the GUI).</p>

<p>Visual Studio may complain that it can&#39;t load the Setup project. This will happen if you do not have InstallShield installed. You can safely ignore this message. Also if you are using Visual Studio Express for Windows Desktop, you can safely ignore the warning that the WebPlayer and WebEditor projects cannot be loaded, as these are not required for loading and running the main Quest project.</p>

<p>You will also need to have a Mercurial client installed - I recommend TortoiseHg (http://tortoisehg.bitbucket.org/). I&#39;d recommend taking some time to familiarise yourself with Mercurial if you&#39;ve not used it before - a good introduction (albeit command-line based) is Hg Init (http://hginit.com/)</p>

<h2>Developer Guidelines</h2>

<h3>Issue Tracker</h3>

<p>The Issue Tracker (https://github.com/textadventures/quest/issues) contains all features which need to be implemented, and all bugs which need to be fixed.</p>

<p>Assign yourself something that looks sensible. It is probably best to pick a small bug first, to give yourself a feel for the code before attempting something major.</p>

<p>You can also create items - if there&#39;s an obvious missing feature or bug, add it to the Issue Tracker, and assign it to yourself if you want to work on it. Check it&#39;s not a duplicate first. And if you&#39;re proposing a major new feature, please suggest it on the forums (or email me) first.</p>

<p>Please ask me for help! I&#39;m happy to answer your questions about how things work, and why things are the way they are. Just send an email to me at <a href="mailto:alex@axeuk.com">alex@axeuk.com</a> or ask in the Quest Forum: <a href="http://www.textadventures.co.uk/forum/viewforum.php?f=10">http://www.textadventures.co.uk/forum/viewforum.php?f=10</a></p>

<p>You can create a fork in GitHub, clone it, and then push your changes to that fork. When you have finished working on your issue, send a Pull Request. I&#39;ll then review the code, and it can then be merged into the main repository.</p>

<h3>Read the documentation</h3>

<p>If you can&#39;t find an issue that&#39;s right for you, make sure you familiarise yourself with the rest of the documentation on this wiki - and don&#39;t forget, because it&#39;s a wiki, you can edit it. So if you find gaps, mistakes, or things that could just be made clearer, please don&#39;t be scared to contribute here too.</p>

<h3>Translating Quest</h3>

<p>If you know a language other than English, why not try translating the English.aslx file? The more languages Quest supports, the better, so please feel free to add any language you can speak!</p>

<p>See <a href="guides/translating_quest.html">Translating Quest</a> for full information.</p>

<h2>Technical Overview</h2>

<h3>Interfaces</h3>

<p>I have tried to create an object-oriented design that separates out the system into its logical components. There are some major interfaces used:</p>

<ul>
<li>  IASL: The Player component doesn&#39;t reference WorldModel directly, instead all communication between the GUI and the game must happen through this interface. This is how we can support both WorldModel (for Quest 5 games) and LegacyASL (for Quest 4 and earlier). Perhaps eventually the Player will support games written for other systems, if we can wrap other open-source components in something that implements the IASL interface.</li>
<li>  IScript: All script commands implement IScript, so something that runs script commands doesn&#39;t need to know anything about the command it&#39;s running.</li>
<li>  IFunction: Only the Expression class implements this. If we want to replace FLEE at some point we should just be able to drop in another class that implements IFunction.</li>
</ul>

<h3>Design Principles</h3>

<p><em>Everything</em> is an element. This makes it much easier for the Editor to work on many different things - objects, functions, etc.</p>

<p>Objects are elements. There are different kinds of objects (the ObjectType enum):</p>

<ul>
<li>  &quot;Normal&quot; objects which are just things in the game. Also, rooms are normal objects.</li>
<li>  Exits</li>
<li>  Commands</li>
<li>  The game object itself</li>
</ul>

<p>The WorldModel is the component that is in charge of tracking all the elements in a game, and maintains the UndoLogger which tracks changes. Objects can change during the game - they can be created and their fields can be changed. Other types of elements can&#39;t. The WorldModel is also used in the Editor, which gives us the benefit of being able to use the same save/load ASLX code, and also Undo support. So although non-object elements can&#39;t change while a game is being <em>played</em>, we must still provide &quot;undo&quot; support for other types of elements in the WorldModel as they may change while being <em>edited</em>.</p>

<p>Worldmodel doesn&#39;t define any game logic - Core.aslx does. This means that a game is free to define its own logic - what objects are visible at any time, how to handle commands etc. - and that game is still playable by the same Quest runtime.</p>

<p>Any change to an element must be undoable. Changes to fields are automatically tracked if the field gets set to a new value, but this is not sufficient for operations such as adding something to a list, as the field will still be set to the same list. In this case we pass a class that implements IUndoAction into the UndoLogger.</p>

<p>The UI must never reference WorldModel directly. When playing games, everything is done via the IASL interface. When editing games, the editor UI talks only to the EditorController, not the WorldModel. This means we can have different editor GUIs eventually - it will make it much simpler to migrate the editor fully from WinForms to WPF, and also opens up the possibility of having an ASP.NET based editor, which would allow users to edit games online.</p>

<p>Within the Player component, as much of the GUI as possible should be HTML. This will make it easier to implement &quot;play online&quot; functionality as we won&#39;t have to reimplement so much in the online player.</p>

    </div>
  </body>
</html>
