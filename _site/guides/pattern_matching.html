<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pattern Matching</title>
    <link rel="stylesheet" href="/bootstrap.min.css">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="container">
      <h1>Pattern Matching</h1>
      <p>When the player types something into Quest, Quest will attempt to match that against the commands in the game. Quest has a long list of commands, in the order that they appear in the code. As libraries are declared right at the top, library commands will be at the top of the list. Quest starts at the <em>bottom</em> of the list, so your own commands will override those in the libraries, as long as there is a match.</p>

<p>So how are matches mades?</p>

<p>There are two types of matches, the simple pattern and the regex.</p>

<h2>Simple Pattern</h2>

<p>The simple pattern matches exact text and simple substitutions. Here are three examples.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  &lt;command name=&quot;log&quot;&gt;
    &lt;pattern type=&quot;simplepattern&quot;&gt;log #text#&lt;/pattern&gt;
    ...
  &lt;/command&gt;

  &lt;command name=&quot;examine&quot;&gt;
    &lt;pattern type=&quot;simplepattern&quot;&gt;examine #object#;x #object#&lt;/pattern&gt;
    ...
  &lt;/command&gt;

  &lt;command name=&quot;give&quot;&gt;
    &lt;pattern type=&quot;simplepattern&quot;&gt;give #object1# to #object2#&lt;/pattern&gt;
    ...
  &lt;/command&gt;
</code></pre></div>
<p>The first will match any input that starts &quot;log &quot; and if it gets a match the rest of the input goes into a local variable called text. If the player types &quot;log found a cup&quot;, then we get a match and the command might add &quot;found a cup&quot; to the game log.</p>

<p>The second form uses the #object# substitution, and Quest will try to match this against an object that is present. If there is no such object in scope then the match will fail. If there is a match then the local variable object will contain the matched object.</p>

<p>Notice that two matches are supplied, separated by a semi-colon. The player can use either &quot;examine&quot; or &quot;x&quot; to invoke this command.</p>

<p>In the third example, two objects are required. Both must be present to make a match, and if they are, they can be referenced as object1 and object2.</p>

<p>Simple patterns get automatically converted to regex expressions by Quest.</p>

<h2>Regex</h2>

<p>A regex is rather more complicated, but a lot more powerful. A regex (also called a regexp, or regular expression) is a sort of string that can be used to match against another string. You could think of it as a template or a set of rules that a string can be compared to.</p>

<p>Quest uses .NET regex rules, and and a quick reference for .NET regex rules can be found here: <a href="http://msdn.microsoft.com/en-us/library/az24scfc.aspx">http://msdn.microsoft.com/en-us/library/az24scfc.aspx</a></p>

<p>Here is the &quot;put&quot; command, using a regex.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  &lt;command name=&quot;put&quot;&gt;
    &lt;pattern&gt;&lt;![CDATA[^put (?&lt;object1&gt;.*) (on|in) (?&lt;object2&gt;.*)$]]&gt;&lt;/pattern&gt;
    ...
  &lt;/command&gt;
</code></pre></div>
<p>First, note that regex matching is the default; compare to simple pattern matching, where you have to specify it with type=&quot;simplepattern&quot;.</p>

<p>The second point is that the pattern is CDATA. This tells Quest that any less than symbols (&quot;&lt;&quot;) are part of the pattern, and not the start of an XML tag. The CDATA part starts &lt;![CDATA[ and ends ]]&gt;. If you are doing this through the GUI, Quest will do that for you.</p>

<p>This, then, is the pattern:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  ^put (?&lt;object1&gt;.*) (on|in) (?&lt;object2&gt;.*)$
</code></pre></div>
<ul>
<li>  ^ and \$ have to match the start and end of the text respectively.</li>
<li>  The curved brackets group a part of the text.</li>
<li>  The (?&lt; ... &gt; ... ) indicates a capture group, that is, a set of characters that we want to use. The part inside the angle brackets, object1, is the name of the variable we can use to access the captured characters, the bit between the &gt; and the ) is a pattern to match.</li>
<li>  The . indicates any character (except newline).</li>
<li>  The * indicates that the previous thing can be matched any number of times.</li>
<li>  The vertical bar indicates either/or, so given the brackets, this will match both &quot;on&quot; and &quot;in&quot;.</li>
</ul>

<p>Quest will attempt to match object1 and object2 to objects that are present.</p>

<h2>A Note About Language Support</h2>

<p>The core quest commands were built with language support. The command is given a pattern inside square brackets, and this tells Quest to use a template. All the templates go into a language specific file. This is the actual give-to command:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  &lt;command name=&quot;give&quot; pattern=&quot;[give]&quot;&gt;
    HandleGiveTo (object1, object2)
  &lt;/command&gt;
</code></pre></div>
<p>This is the template for English.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  &lt;template templatetype=&quot;command&quot; name=&quot;give&quot;&gt;&lt;![CDATA[^give (?&lt;object1&gt;.*) to (?&lt;object2&gt;.*)$]]&gt;&lt;/template&gt;
</code></pre></div>
<h2>A Note About Verb Templates</h2>

<p>Verb templates seem to offer another simple method for matching. Instead of defining a pattern, you specify a template (might have been better called a verbtemplate?), and in the language file you specify your verb templates.</p>

<p>I would guess that Quest attempts to match against each verbtemplate with the objects present, and if it finds a match, it links that back to the command. You can have several verbtempates for one command. Here is an example from the Quest library.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  &lt;command name=&quot;lookat&quot; template=&quot;lookat&quot;&gt;
    ...
  &lt;/command&gt;

  &lt;verbtemplate name=&quot;lookat&quot;&gt;look at&lt;/verbtemplate&gt;
  &lt;verbtemplate name=&quot;lookat&quot;&gt;x&lt;/verbtemplate&gt;
  &lt;verbtemplate name=&quot;lookat&quot;&gt;examine&lt;/verbtemplate&gt;
  &lt;verbtemplate name=&quot;lookat&quot;&gt;exam&lt;/verbtemplate&gt;
  &lt;verbtemplate name=&quot;lookat&quot;&gt;ex&lt;/verbtemplate&gt;
</code></pre></div>
    </div>
  </body>
</html>
