<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Expressions</title>
    <link rel="stylesheet" href="/bootstrap.min.css">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="container">
      <h1>Expressions</h1>
      <p>Quest handles expressions throughout all script commands. Whereas in previous versions, things like string variables had to be denoted using special characters, in Quest you can use expressions everywhere, just as you can in ordinary programming languages.</p>

<p>Of course, many games will only ever need very simple expressions, and the visual editor will mean that many game authors may never need to write one directly. But, with Quest, the full power of expressions is available everywhere if you need it.</p>

<p>This means no more special characters are required to denote variables and functions, and also the &quot;if&quot; command gets the full power of expressions – you can use nested expressions with &quot;and&quot; and &quot;or&quot;, negate expressions with &quot;not&quot;, and compare expressions directly. &quot;And&quot; and &quot;or&quot; support short-circuit evaluation; however, all terms must be be evaluable. That means that an idiom like &quot;if (HasAttribute(o, &quot;att&quot;) and o.att)&quot; will cause a compile error if o.att is not defined, as the expression must be <em>able</em> to be evaluated even if it is not, actually, evaluated.</p>

<p>Here are some example script commands containing expressions:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"> foreach (obj, GetObjectsInScope(&quot;Visible&quot;)) {
   msg (&quot;You can see: &quot; + obj.name)
 }

 if ((a and b) or (c and d) or (somenumber * 3 &gt; somethingelse)) { .... }

 foreach (obj, somelist + anotherlist + SomeFunctionReturningAList(blah)) {
   ....
 }

 MyCustomFunction(a, b, c+d)

 player.parent = GetRandomRoom(GetNearbyRooms(player.parent))

 someobject.take =&gt; {
   msg (&quot;Blah blah&quot;)
   someobject.counter = someobject.counter + someotherobject.someproperty
 }
</code></pre></div>
<p>Quest also supports local variables. This means you can reuse the same simple variable name inside different functions, if you don’t need to access that value outside the function. You don’t need to declare variables in advance – you can just use them by setting them.</p>

<p>Global variables are now just properties of the &quot;game&quot; object, which means the entire state of the game is always defined entirely by object properties.</p>

    </div>
  </body>
</html>
